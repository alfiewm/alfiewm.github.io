<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>【翻】 MVC, MVP, MVVM终极对决 | 不学无术</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/
过去几年，在使用何种设计模式实现Android应用程序的话题上，我们不停的在尝试新的方式。整体上来说，大家从原来的传统的MVC模式转变为青睐更加模块化、便与测试的新新模式。
Model View Presenter (MVP) 和 Model View ViewModel">
<meta property="og:type" content="article">
<meta property="og:title" content="【翻】 MVC, MVP, MVVM终极对决">
<meta property="og:url" content="http://alfiewm.github.io/2017/02/08/translation/mvc-mvp-mvvm-smackdown/index.html">
<meta property="og:site_name" content="不学无术">
<meta property="og:description" content="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/
过去几年，在使用何种设计模式实现Android应用程序的话题上，我们不停的在尝试新的方式。整体上来说，大家从原来的传统的MVC模式转变为青睐更加模块化、便与测试的新新模式。
Model View Presenter (MVP) 和 Model View ViewModel">
<meta property="og:updated_time" content="2017-02-09T15:22:44.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="【翻】 MVC, MVP, MVVM终极对决">
<meta name="twitter:description" content="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/
过去几年，在使用何种设计模式实现Android应用程序的话题上，我们不停的在尝试新的方式。整体上来说，大家从原来的传统的MVC模式转变为青睐更加模块化、便与测试的新新模式。
Model View Presenter (MVP) 和 Model View ViewModel">
  
    <link rel="alternative" href="/atom.xml" title="不学无术" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <script src="/style.js"></script>
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="https://avatars2.githubusercontent.com/u/5260298?v=3&amp;s=466" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">alfiewm</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">alfiewm</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="https://avatars2.githubusercontent.com/u/5260298?v=3&amp;s=466" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">alfiewm</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-translation/mvc-mvp-mvvm-smackdown" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      【翻】 MVC, MVP, MVVM终极对决
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><a href="https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/" target="_blank" rel="external">https://realm.io/news/eric-maxwell-mvc-mvp-and-mvvm-on-android/</a></p>
<p>过去几年，在使用何种设计模式实现Android应用程序的话题上，我们不停的在尝试新的方式。整体上来说，大家从原来的传统的MVC模式转变为青睐更加模块化、便与测试的新新模式。</p>
<p>Model View Presenter (MVP) 和 Model View ViewModel(MVVM) 是当前被广泛使用的两种模式，开发者也划分为两派，分别认为各自的模式更加适合Android应用程序的开发，网络上有超多的blog来表名一种比另外一种更好，但最终这种争吵并无意义，因为没有什么客观的证据证明一种比另外一种更好。本文无意比较三种模式的好坏，只是尝试客观的评价一下三种模式的优势和劣势，至于哪一种最好，还是萝卜青菜，各有所爱吧。</p>
<p>我们使用简单的Tic-Tac-Toe游戏项目来帮助我们理解。 提醒一下，本文会按照MVC，MVP，MVVM的顺序分别讲解，每部分开始前会简单定义一下主要的模块和及其职责，接着会看如何体现在我们的示例程序中。</p>
<p>示例程序源码可以在<a href="https://github.com/ericmaxwell2003/ticTacToe" target="_blank" rel="external">这里</a>找到。可以下载源码并checkout对应的分支便于理解(e.g. git checkout mvc, git checkout mvp, git checkout mvvm)。</p>
<h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p>MVC模型将应用程序划分为3个部分分别负责不同的职责。</p>
<p>Model</p>
<p>Model在我们的例子中就是数据+状态+业务逻辑，是应用的核心模块，model并不依赖View或者Controller，所以可以在多个地方重用。</p>
<p>View</p>
<p>View是Model的外在表现。View负责绘制UI并将用户的交互事件传递给Controller。在MVC模型中，View一般比较“傻”，它不知道Model的存在，也不管理状态，用户交互时（点击，输入等），它也只是简单传递出去。之所以这么做的原因是，View知道的越少，它和Model之间的耦合就越低，当它变化时就能更灵活。</p>
<p>Controller</p>
<p>Controller在模型中扮演了胶水的角色，它将Model和View关联在了一起。当View告诉Controller用户点击了一个按钮，Controller决定如何影响Model，并根据Model的变化反向控制View的状态。在Android应用中，通常Activity或者Fragment扮演的就是Controller的角色。</p>
<p>【具体代码参看Github】</p>
<pre><code>
public class TicTacToeActivity extends AppCompatActivity {

    private Board model;

    /* View Components referenced by the controller */
    private ViewGroup buttonGrid;
    private View winnerPlayerViewGroup;
    private TextView winnerPlayerLabel;

    /**
     * In onCreate of the Activity we lookup & retain references to view components
     * and instantiate the model.
     */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.tictactoe);
        winnerPlayerLabel = (TextView) findViewById(R.id.winnerPlayerLabel);
        winnerPlayerViewGroup = findViewById(R.id.winnerPlayerViewGroup);
        buttonGrid = (ViewGroup) findViewById(R.id.buttonGrid);

        model = new Board();
    }

    /**
     * Here we inflate and attach our reset button in the menu.
     */
    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        MenuInflater inflater = getMenuInflater();
        inflater.inflate(R.menu.menu_tictactoe, menu);
        return true;
    }
    /**
     *  We tie the reset() action to the reset tap event.
     */
    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case R.id.action_reset:
                reset();
                return true;
            default:
                return super.onOptionsItemSelected(item);
        }
    }

    /**
     *  When the view tells us a cell is clicked in the tic tac toe board,
     *  this method will fire. We update the model and then interrogate it's state
     *  to decide how to proceed.  If X or O won with this move, update the view
     *  to display this and otherwise mark the cell that was clicked.
     */
    public void onCellClicked(View v) {

        Button button = (Button) v;

        int row = Integer.valueOf(tag.substring(0,1));
        int col = Integer.valueOf(tag.substring(1,2));

        Player playerThatMoved = model.mark(row, col);

        if(playerThatMoved != null) {
            button.setText(playerThatMoved.toString());
            if (model.getWinner() != null) {
                winnerPlayerLabel.setText(playerThatMoved.toString());
                winnerPlayerViewGroup.setVisibility(View.VISIBLE);
            }
        }

    }

    /**
     * On reset, we clear the winner label and hide it, then clear out each button.
     * We also tell the model to reset (restart) it's state.
     */
    private void reset() {
        winnerPlayerViewGroup.setVisibility(View.GONE);
        winnerPlayerLabel.setText("");

        model.restart();

        for( int i = 0; i < buttonGrid.getChildCount(); i++ ) {
            ((Button) buttonGrid.getChildAt(i)).setText("");
        }
    }
}
</code></pre>

<p>评价 - MVC在划分View和Model方面做得很好。因此Model可以很方便的进行测试因为它没有绑定任何东西，而View在单元测试方面并没有什么好测的，但Controller存在一些问题。</p>
<ul>
<li>可测试性 - Controller与Android API紧密耦合，导致很难单元测试</li>
<li>模块化和灵活性 - Controller与View耦合太过紧密，甚至Controller就是View的一部分，当View发生变化时，经常需要我们去改动Controller</li>
<li>可维护性 - 随着时间推移，Controller经常会承担越来越多的功能，变得臃肿不堪而难以维护。</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>MVP模型将Controller进行了拆分，view和activity不需要再负担除了UI之外的其他职责。下面会详细说明，我们先对比MVC来看一下职责划分。</p>
<p>Model</p>
<p>与MVC中的Model一样</p>
<p>View</p>
<p>唯一的变化是Activity和Fragment也被当做是View的一部分。这样也更自然一些。一个比较好的做法是让Activity/Fragment是想View的接口，presenter通过接口来操作View。这样以来，presenter就不依赖于具体的View，我们就可以mock一个假的View来进行单元测试。</p>
<p>Presenter</p>
<p>实质上就是MVC中的Controller，只不过它不再绑定具体的View，而仅仅是一个接口。这样就解决了MVC可测试性和灵活性的问题。MVP的忠实信徒甚至主张Presenter不应该引用任何Android相关的API或者代码。</p>
<p>详细看一下Presenter的实现，你就会发现它非常的简单干净。它不会具体操作View如何展现，而仅仅告诉View要展现什么。</p>
<pre><code>
public class TicTacToePresenter implements Presenter {

    private TicTacToeView view;
    private Board model;

    public TicTacToePresenter(TicTacToeView view) {
        this.view = view;
        this.model = new Board();
    }

    // Here we implement delegate methods for the standard Android Activity Lifecycle.
    // These methods are defined in the Presenter interface that we are implementing.
    public void onCreate() { model = new Board(); }
    public void onPause() { }
    public void onResume() { }
    public void onDestroy() { }

    /**
     * When the user selects a cell, our presenter only hears about
     * what was (row, col) pressed, it's up to the view now to determine that from
     * the Button that was pressed.
     */
    public void onButtonSelected(int row, int col) {
        Player playerThatMoved = model.mark(row, col);

        if(playerThatMoved != null) {
            view.setButtonText(row, col, playerThatMoved.toString());

            if (model.getWinner() != null) {
                view.showWinner(playerThatMoved.toString());
            }
        }
    }

    /**
     *  When we need to reset, we just dictate what to do.
     */
    public void onResetSelected() {
        view.clearWinnerDisplay();
        view.clearButtons();
        model.restart();
    }
}
</code></pre>

<p>我们让Activity来实现下面的View接口，从而实现Activity与Presenter的解耦。只需要mock一个实现该接口的对象即可测试Presenter和View的交互。</p>
<p>评价 - MVP模型看起来比MVC更加干净，因为Presenter不再依赖任何Android相关的API和代码，我们可以轻易对其进行单元测试。同时我们也可以复用该Presenter到其他任何实现了TicTacToeView接口的View去。</p>
<p>Presenter 顾虑：</p>
<ul>
<li>可维护性 - Presenter和Controller类似，随着时间推移，不可避免的会累积越来越多的业务逻辑。开发者最终会发现这些庞大的Presenter非常难以拆分维护。</li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>MVVM配合Android的数据绑定可以实现更简单的可测试性和模块化，同时也可以减少我们为了连接View和Model而写的胶水代码。</p>
<p>Model</p>
<p>与MVC中的Model一样</p>
<p>View</p>
<p>View绑定到ViewModel中可被观察的变量和操作上，下面会详说</p>
<p>ViewModel</p>
<p>ViewModel负责处理Model生成View所需要的可被观察的数据。它也会为View提供钩子来传递交互事件，然而ViewModel并不知道View的存在，所以也不存在依赖。</p>
<p>看一下详细代码</p>
<pre><code>
public class TicTacToeViewModel implements ViewModel {

    private Board model;

    /*
     * These are observable variables that the viewModel will update as appropriate
     * The view components are bound directly to these objects and react to changes
     * immediately, without the ViewModel needing to tell it to do so. They don't
     * have to be public, they could be private with a public getter method too.
     */
    public final ObservableArrayMap<string, string=""> cells = new ObservableArrayMap<>();
    public final ObservableField<string> winner = new ObservableField<>();

    public TicTacToeViewModel() {
        model = new Board();
    }

    // As with presenter, we implement standard lifecycle methods from the view
    // in case we need to do anything with our model during those events.
    public void onCreate() { }
    public void onPause() { }
    public void onResume() { }
    public void onDestroy() { }

    /**
     * An Action, callable by the view.  This action will pass a message to the model
     * for the cell clicked and then update the observable fields with the current
     * model state.
     */
    public void onClickedCellAt(int row, int col) {
        Player playerThatMoved = model.mark(row, col);
        cells.put("" + row + col, playerThatMoved == null ?
                                                     null : playerThatMoved.toString());
        winner.set(model.getWinner() == null ? null : model.getWinner().toString());
    }

    /**
     * An Action, callable by the view.  This action will pass a message to the model
     * to restart and then clear the observable data in this ViewModel.
     */
    public void onResetSelected() {
        model.restart();
        winner.set(null);
        cells.clear();
    }

}
</string></string,></code></pre>

<p>{code}<br>&lt;!–<br>    With Data Binding, the root element is <layout>.  It contains 2 things.</layout></p>
<pre><code>1. &lt;data&gt; - We define variables to which we wish to use in our binding expressions and
            import any other classes we may need for reference, like android.view.View.
2. &lt;root layout&gt; - This is the visual root layout of our view.  This is the root xml tag in the MVC and MVP view examples.
</code></pre><p>–&gt;</p>
<layout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" xmlns:app="http://schemas.android.com/apk/res-auto">

<pre><code>&lt;!-- We will reference the TicTacToeViewModel by the name viewModel as we have defined it here. --&gt;
&lt;data&gt;
    &lt;import type=&quot;android.view.View&quot; /&gt;
    &lt;variable name=&quot;viewModel&quot; type=&quot;com.acme.tictactoe.viewmodel.TicTacToeViewModel&quot; /&gt;
&lt;/data&gt;
&lt;LinearLayout...&gt;
    &lt;GridLayout...&gt;
        &lt;!-- onClick of any cell in the board, the button clicked will invoke the onClickedCellAt method with its row,col --&gt;
        &lt;!-- The display value comes from the ObservableArrayMap defined in the ViewModel  --&gt;
        &lt;Button
            style=&quot;@style/tictactoebutton&quot;
            android:onClick=&quot;@{() -&gt; viewModel.onClickedCellAt(0,0)}&quot;
            android:text=&apos;@{viewModel.cells[&quot;00&quot;]}&apos; /&gt;
        ...
        &lt;Button
            style=&quot;@style/tictactoebutton&quot;
            android:onClick=&quot;@{() -&gt; viewModel.onClickedCellAt(2,2)}&quot;
            android:text=&apos;@{viewModel.cells[&quot;22&quot;]}&apos; /&gt;
    &lt;/GridLayout&gt;

    &lt;!-- The visibility of the winner view group is based on whether or not the winner value is null.
         Caution should be used not to add presentation logic into the view.  However, for this case
         it makes sense to just set visibility accordingly.  It would be odd for the view to render
         this section if the value for winner were empty.  --&gt;
    &lt;LinearLayout...
        android:visibility=&quot;@{viewModel.winner != null ? View.VISIBLE : View.GONE}&quot;
        tools:visibility=&quot;visible&quot;&gt;

        &lt;!-- The value of the winner label is bound to the viewModel.winner and reacts if that value changes --&gt;
        &lt;TextView
            ...
            android:text=&quot;@{viewModel.winner}&quot;
            tools:text=&quot;X&quot; /&gt;
        ...
    &lt;/LinearLayout&gt;
&lt;/LinearLayout&gt;
</code></pre><p></p></layout><br>{code}<p></p>
<p>小技巧：尽量多使用tools属性。如上示例，tools属性被用来展示赢家和设置，如果不使用的话，在设计时比较难以想象最终的效果。</p>
<p>PS：上面的示例只是Data Binding的最基本的使用，它要更加强大的多，墙裂建议你去查看一下Android Data Binding的<a href="https://developer.android.com/topic/libraries/data-binding/index.html" target="_blank" rel="external">文档</a>。本文的末尾也有一个链接到google的开源架构项目，里面有更多关于MVVM和Data Binding的例子。</p>
<p>评价 - 单元测试变得更简单了，因为现在没有对View的任何依赖了。测试时，只需要验证一下当Model变化时，所有的被观察变量被正确修改即可，不需要像MVP那样需要mock一个View。</p>
<p>问题：</p>
<ul>
<li>可维护性 - 不相关的外部逻辑可能会污染View，导致XML比较复杂，因为View可以绑定变量或者表达式。可以通过直接绑定ViewModel的值而不是通过表达式来回避这个问题，这样一来所有的计算逻辑也都可以被单元测试覆盖。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVP和MVVM在模块化方面做得都比MVC要好，但是同时也增加了复杂性，对于简单的只有一两个页面的应用，MVC可能已经足够了。MVVM配合Data Binding因为更Reactive，并且代码更少，看起来更吸引人一些。</p>
<p>那么，你觉得哪一种更适合你呢？如果你决定在MVP和MVVM中进行选择，最终可能也就是根据个人偏好做出决定，如果能实际看到它们如何使用将更能帮你理解他们的优劣。</p>
<p>如果你有兴趣了解关于MVP和MVVM更多的实例，建议你去把玩一下Google的<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">Android架构工程</a>。网上也有很多更深入探讨MVP实现的博客，去看看吧。</p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2017/02/08/translation/mvc-mvp-mvvm-smackdown/" class="archive-article-date">
  	<time datetime="2017-02-07T16:04:50.000Z" itemprop="datePublished"><i class="icon-clock"></i>2017-02-08</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
  
    <a href="/2017/02/08/shame/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">懒癌晚期</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>









      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 alfiewm
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>